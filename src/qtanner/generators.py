"""Generator set helpers for finite groups."""

from __future__ import annotations

from collections import Counter
from itertools import combinations, combinations_with_replacement
from typing import Iterator, List, Set

from .group import FiniteGroup


def subgroup_generated(group: FiniteGroup, gens: List[int]) -> Set[int]:
    """Return the subgroup generated by gens as a set of elements."""
    if group.order == 0:
        return set()
    generators = list(gens)
    gens_with_inv = set(generators)
    for g in generators:
        gens_with_inv.add(group.inv_of(g))
    step_gens = sorted(gens_with_inv)
    seen = {0}
    queue = [0]
    while queue:
        cur = queue.pop()
        for g in step_gens:
            nxt = group.mul(cur, g)
            if nxt not in seen:
                seen.add(nxt)
                queue.append(nxt)
    return seen


def is_generating(group: FiniteGroup, gens: List[int]) -> bool:
    """Return True if gens generate the full group."""
    return len(subgroup_generated(group, gens)) == group.order


def iter_generator_sets(
    group: FiniteGroup,
    size: int,
    *,
    include_identity: bool = True,
    distinct: bool = True,
    min_distinct_nonid: int | None = None,
    max_multiplicity_nonid: int | None = None,
    order_by_diversity: bool = True,
    max_sets: int | None = None,
) -> Iterator[List[int]]:
    """Yield generating sets of given size as sorted lists."""
    if size < 0:
        return
    elements = list(range(group.order))
    emitted = 0

    def _nonid_stats(values: List[int] | tuple[int, ...]) -> tuple[int, int]:
        nonid = [val for val in values if val != 0]
        if not nonid:
            return 0, 0
        counts = Counter(nonid)
        return len(counts), max(counts.values())

    def _passes_multiset_filters(values: List[int] | tuple[int, ...]) -> bool:
        distinct_count, max_mult = _nonid_stats(values)
        if min_distinct_nonid is not None and distinct_count < min_distinct_nonid:
            return False
        if max_multiplicity_nonid is not None and max_mult > max_multiplicity_nonid:
            return False
        return True

    if include_identity:
        if size == 0:
            return
        remaining = size - 1
        if distinct:
            pool = elements[1:]
            combos = combinations(pool, remaining)
            for comb in combos:
                candidate = [0, *comb]
                candidate.sort()
                if is_generating(group, candidate):
                    yield candidate
                    emitted += 1
                    if max_sets is not None and emitted >= max_sets:
                        return
        else:
            pool = elements[1:]
            combos = combinations_with_replacement(pool, remaining)
            if (
                min_distinct_nonid is not None
                or max_multiplicity_nonid is not None
                or order_by_diversity
            ):
                ranked: list[tuple[tuple[int, ...], int, int]] = []
                for comb in combos:
                    if not _passes_multiset_filters(comb):
                        continue
                    distinct_count, max_mult = _nonid_stats(comb)
                    ranked.append((comb, distinct_count, max_mult))
                if order_by_diversity:
                    ranked.sort(key=lambda item: (-item[1], item[2], item[0]))
                for comb, _, _ in ranked:
                    candidate = [0, *comb]
                    candidate.sort()
                    if is_generating(group, candidate):
                        yield candidate
                        emitted += 1
                        if max_sets is not None and emitted >= max_sets:
                            return
            else:
                for comb in combos:
                    candidate = [0, *comb]
                    candidate.sort()
                    if is_generating(group, candidate):
                        yield candidate
                        emitted += 1
                        if max_sets is not None and emitted >= max_sets:
                            return
        return

    if distinct:
        combos = combinations(elements, size)
    else:
        combos = combinations_with_replacement(elements, size)
        if (
            min_distinct_nonid is not None
            or max_multiplicity_nonid is not None
            or order_by_diversity
        ):
            ranked = []
            for comb in combos:
                if not _passes_multiset_filters(comb):
                    continue
                distinct_count, max_mult = _nonid_stats(comb)
                ranked.append((comb, distinct_count, max_mult))
            if order_by_diversity:
                ranked.sort(key=lambda item: (-item[1], item[2], item[0]))
            for comb, _, _ in ranked:
                candidate = list(comb)
                if is_generating(group, candidate):
                    yield candidate
                    emitted += 1
                    if max_sets is not None and emitted >= max_sets:
                        return
            return

    for comb in combos:
        candidate = list(comb)
        if is_generating(group, candidate):
            yield candidate
            emitted += 1
            if max_sets is not None and emitted >= max_sets:
                return


__all__ = ["subgroup_generated", "is_generating", "iter_generator_sets"]
